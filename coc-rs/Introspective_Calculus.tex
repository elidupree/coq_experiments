\documentclass{article}

\usepackage{tikz}
\usepackage{amsfonts}
\usepackage{amssymb}
%\usepackage[nointegrals]{wasysym}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage{nameref}
\usepackage{xcolor}

\usepackage[english]{babel}
\usepackage[autostyle]{csquotes}
\usepackage{amsmath}
\usepackage{wasysym}
\MakeOuterQuote{"}

%\usepackage[backend=biber,style=numeric]{biblatex}
%\addbibresource{Introspective_Calculus.bib}

\title{The Introspective Calculus}
\author{Eli Dupree}
\date{\today}

\DeclareMathSymbol{\mlq}{\mathord}{operators}{``}
\DeclareMathSymbol{\mrq}{\mathord}{operators}{`'}

\begin{document}
  \maketitle
  
  \section{Introduction}
  
  This document is a bare-bones explanation of my current definitions of this calculus.
  I plan to later develop it into a full, polished explanation, once I'm more confident in its soundness.
  
  In type theory, the source of paradoxes (like Russell's paradox and Girard's paradox) is this:
  
  \begin{itemize}
    \item A function $F$ takes a parameter $x$ whose type is a function type, and thereby defines \emph{infinite premises} (because $x$ must be correct for every possible value of $x$'s own parameter).
    \item The type derivation for $F$ then uses these infinite premises to derive \emph{infinite conclusions} (the fact that $F$ itself is correct for every possible value of $x$).
    \item By jiggling the infinities, the paradox makes these two infinities line up with each other with a slight offset, so it can pull an instance of False out of the loose end.
  \end{itemize}
  
  Type theories typically prevent this by limiting how you can jiggle the infinities.
  The present work's innovation is to prevent infinities directly, by adding an unremovable placeholder for every time you create or apply an abstraction, so that the finite-ness of the placeholder stack proves the finite-ness of the proof.
  This allows us to remove the other limitations.
  In particular, the source of the name "Introspective Calculus" is that every rule of IC can be abstracted over within IC.

  The placeholders take the form of well-founded sets, which avoid the Burali-Forti paradox by being subject to the same finite-ness requirements themselves.


  
  Section \ref{fundamentals} (\textit{\nameref{fundamentals}}) gives a formal definition of IC.  

  \section{Fundamentals}\label{fundamentals}

  \subsection{Syntax}
  \begin{align*}
     Atom :=&\ \mathrm{here} \mid \mathrm{hole} \mid \mathrm{implies} \mid \mathrm{unfoldsto} \mid \mathrm{abstraction} \mid \mathrm{variable} \mid \mathrm{clock} \mid\\
      &\ \ \ \ \mathrm{plus} \mid \mathrm{minus} \mid \mathrm{well\_founded\_zero} \mid \mathrm{well\_founded\_successor}\\
     F :=&\ Atom \mid (F F)
  \end{align*}

  \subsection{Notations}
  
%  \[ A\ B\ C \dots Y\ Z := ((\dots ((A B) C) \dots Y) Z) \]
  
  \newcommand{\here}{\bigstar}
  \newcommand{\hole}{\circ}
  \newcommand{\wfz}{0}
  \newcommand{\wfsucc}{\operatorname{\mathrm{S}}}
  
  \renewcommand{\implies}{\rightarrow}
  \newcommand{\proves}{\vdash}
  \newcommand{\wellfounded}{\operatorname{\mathrm{well\_founded}}}
  \newcommand{\unfoldsto}{\looparrowright}
  \newcommand{\abstraction}[2]{\Rightarrow\hspace{-0.4em}[#1]\,#2}
  \newcommand{\variable}[1]{{\mathcal{V}_{\mlq\hspace{-0.06em}#1\hspace{-0.06em}\mrq}}}
  \newcommand{\clocksub}[1]{\text{\clock}_{\!#1}}
  \newcommand{\nameabstraction}[1]{#1 \Rightarrow}
  \newcommand{\axiom}[2]{#1 := #2}

  \begin{align*}
    \here &:= \mathrm{here}\\
    \hole &:= \mathrm{hole}\\
    + &:= \mathrm{plus}\\
    - &:= \mathrm{minus}\\
    \wfz &:= \mathrm{well\_founded\_zero}\\
    \wfsucc &:= \mathrm{well\_founded\_successor}\\
    (A \implies B) &:= ((\mathrm{implies}\ A) B),\ \operatorname{right-associative}\\
    (A \unfoldsto B) &:= ((\mathrm{unfoldsto}\ A) B)\\
    (\abstraction{A}{B}) &:= ((\mathrm{abstraction}\ A) B)\\
    (\variable{A}) &:= (\mathrm{variable}\ A)\\
    \clocksub{A} &:= (\mathrm{clock}\ A)\\
  \end{align*}

  Finally, we define the \emph{named form} of abstractions, $(\nameabstraction{A}B),\ \operatorname{right-associative}$.
  This is defined as $(\abstraction{L}{B'})$, where both $B'$ and $L$ (the \emph{variable locations}) are copies of $B$ with the following replacements:
  \begin{itemize}
    \item In $L$, replace any subtree that has no usages of $A$ with the atom $\hole$.
    \item In $L$, replace all usages of $A$ with the atom $\here$.
    \item In $B'$, replace all usages of $A$ with the atom $\hole$.
  \end{itemize}

  \subsection{Axiom Definitions}
  \setlength{\jot}{1.4em}
  \begin{gather*}
    \tag{modus ponens}\label{mp}
    \inferrule{(A \implies B)\\\\A}{B}\\
  \end{gather*}
  All remaining axioms are defined as implications ($Premise \implies Premise \dots \implies Conclusion$), which allows them to be reasoned about internally. (The external form can be derived using \eqref{mp}.) However, we still write them as $\frac{Premise\dots}{Conclusion}$ for readability.
  \\\\
  Implication:
  \begin{gather*}
    \tag{weakening}
    \inferrule{B}{A \implies B}\\
    \tag{implication within hypothetical}
    \inferrule{C \implies (A \implies B)\\\\C \implies A}{C \implies B}\\
  \end{gather*}
  Proofs:
  \begin{gather*}
    \tag{axioms prove things}\label{axp}
    \inferrule{\axiom{A}{B}}{A \proves B}\\
    \tag{implication within proofs}
    \inferrule{P \proves (A \implies B)\\\\Q \proves A}{(PQ)\proves B}\\
    \tag{induction on proofs}
    \inferrule{A \proves B\\\\\nameabstraction{P}\nameabstraction{Q} (\axiom{P}{Q}) \implies RPQ\\\\\nameabstraction{P}\nameabstraction{Q}\nameabstraction{A}\nameabstraction{B} R P (A\implies B) \implies R QA\implies R(PQ)B}{R(PQ)B}\\
  \end{gather*}
  Substitution:
  \begin{gather*}
    \tag{replace here}
    \inferrule{}{((\abstraction{\here}{B}) C) \unfoldsto C}\\
    \tag{replace not here}
    \inferrule{}{((\abstraction{\hole}{B}) C) \unfoldsto B}\\
    \tag{replace in both}
    \inferrule{
      ((\abstraction{A}{B}) C) \unfoldsto D\\\\
      ((\abstraction{E}{F}) G) \unfoldsto H
    }{
      ((\abstraction{(AE)}{(BF)}) (CG)) \unfoldsto (DH)
    }\\
  \end{gather*}
  Abstraction:
  \begin{gather*}
    \tag{evaluation of predicates}
    \inferrule{((\abstraction{x}{B})v) \unfoldsto C\\\\C}{(\abstraction{x}{B})v}\\
    \tag{generalization}
    \inferrule{(\abstraction{x}{(A \proves B)})\ \variable{B}}{\abstraction{x}{B}}\\
    \tag{specialization}
    \inferrule{((\abstraction{x}{B}) v) \unfoldsto C\\\\A \proves (\abstraction{x}{B})}{C}\\
%    \tag{induction}
%    \inferrule{P\ Atom\dots\\\\\nameabstraction{A} \nameabstraction{B} P A \implies P B \implies P (A B)}{P C}\\
  \end{gather*}
  Axiom rules:
  \begin{gather*}
    \tag{successor axioms}\label{axs}
    \inferrule{\axiom{A}{B}}{\axiom{(\wfsucc A)}{(\axiom{A}{B})}}\\
    \tag{axiom definitions are unique}\label{axu}
    \inferrule{\axiom{A}{B}\\\\\axiom{A}{C}\\\\PB}{PC}\\
    \tag{induction on axioms}\label{axe}
    \inferrule{\axiom{A}{B}\\\\P\text{``modus ponens"}\\\\\dots\\\\P\text{``induction on axioms"}\\\\(\nameabstraction{a} Pa \implies P(\wfsucc a))}{PA}\\
  \end{gather*}

  \subsection{Internal Axioms}

  We now define \emph{internal} versions of the above axioms.

  From the internal perspective of the calculus, the above axioms provide truth for any \emph{specific} values of the variables $A, B\dots$, but cannot prove abstractions over those variables.
  So, for each axiom, we also create an internal form, by representing the variables using abstractions, and the premises using implication.
  For example, (modus ponens) is represented as:

  \begin{equation*}
    \tag{modus ponens, internal}\label{mpi}
    \axiom{\operatorname{\mathrm{``modus\ ponens"}}}{
      (\nameabstraction{A} \nameabstraction{B} (A \implies B) \implies A \implies B)
    }\\
  \end{equation*}

  Of course, \eqref{mpi} is now an axiom that does not have an explicit internal form!
  Fortunately, we do not need an infinite regression of \emph{explicit} definitions. Since \eqref{mpi} has no metavariables or premises, \eqref{axs} can take care of it, giving us:

  \begin{equation*}
    \axiom{(\wfsucc\operatorname{\mathrm{``modus\ ponens"}})}{(
      \axiom{\operatorname{\mathrm{``modus\ ponens"}}}{
        (\nameabstraction{A} \nameabstraction{B} (A \implies B) \implies A \implies B)
      }
    )}\\
  \end{equation*}

  and so forth.

  \section{Examples}\label{structure}

  We can define the conventional logical connectives in terms of the above rules:

  \setlength{\jot}{0.4em}
  \begin{align*}
    \tag{false/absurdity}
    \bot &:= (\nameabstraction{P}{P})\\
    \tag{negation}
    \neg P &:= ({P \implies \bot})\\
    \mathrm{not} &:= (\nameabstraction{P} \neg P)\\
    \tag{conjunction}
    P \land Q &:= (\nameabstraction{R} (P \implies Q \implies R) \implies R)\\
    \mathrm{and} &:= (\nameabstraction{P}\nameabstraction{Q} P \land Q)\\
    \tag{disjunction}
    P \lor Q &:= (\nameabstraction{R} (P \implies R) \implies (Q \implies R) \implies R)\\
    \mathrm{or} &:= (\nameabstraction{P}\nameabstraction{Q} P \lor Q)\\
    \tag{existential quantification}
    \exists x, P(x) &:= (\nameabstraction{R} (\nameabstraction{x} P(x) \implies R) \implies R)\\
  \end{align*}

%  And we can prove some tautologies:
%  \begin{align*}
%  (P \land Q)
%  \end{align*}

  \section{Consistency}\label{consistency}
  
  We regard a proposition $P$ as "proven" if it is \emph{eventually true} within IC, i.e.
  
  \newcommand{\eventually}{\operatorname{\mathrm{Eventually}}}
  
  \[ \eventually P := \exists n, \clocksub{+n} P \]
  
  This is a meta-theoretical definition; if we use our internal definition of $\exists$, which contains 2 nested abstractions, then you can never prove $(\eventually P)$, only $\clocksub{+2}(\eventually P)$.
  
  That said, since every axiom of IC can be applied within clocks, we could view the inside of $\clocksub{+n}$ as being another instance of the calculus – call it IC$_{+n}$ – which adds the axiom "if $\clocksub{+n} P$ is true in IC, then $P$ is true in IC$_{+n}$". If we move to IC$_{+2}$, we \emph{can} be comfortable with an internal definition of $\eventually$. Thus, IC can function as its own metatheory, just with a clock offset.
  
  By the axiom \eqref{lne}, anything that's eventually true is also eternally true, in the sense that you can "wait" for an IC$_{+n}$ where P is as old as you want:
  
  \[ \nameabstraction{n} \wellfounded n \implies \eventually P \implies \eventually \clocksub{-n} P \]
  
  One might ask: What if you can't prove $(\eventually P)$, but only $\eventually (\eventually P)$? One might hope that $\eventually (\eventually P)$ implies $(\eventually P)$, but it does not – it only implies $\clocksub{+constant}(\eventually P)$. But could we also regard that as "proving $P$"? Unfortunately, if we did, we would then want to extend it to $\eventually (\eventually (\eventually P))$, and so forth. For the sake of having a single definition, the answer must be \emph{no}. But the purpose of including the entire well-founded hierarchy is that you don't \emph{need} to.
  
  Intuitively, the only way to prove $(\eventually P)$ is to exhibit a \emph{specific} $n$ where you can prove $\clocksub{+n} P$. Assuming this is true, you can simply take that value of $n$ Unfortunately, you can't prove this within IC, because the internal logic of IC doesn't know that there aren't extra axioms that could make $\eventually P$ true for other reasons. However, what you \emph{can} do is to define a predicate
  
  \newcommand{\provable}{\operatorname{\mathrm{Provable}}}
  
  \[\provable P := \dots\]
  
  which is true for anything that can be proved from the actual axioms of IC. (You define this as an induction predicate, with the axioms of IC as cases; we omit the definition because it is long.)
  
  A digression on the properties of $\provable$: Meta-theoretically, we don't think you can prove anything that's not $\eventually \provable$. But this is impossible to prove inside IC, for the same reasons as above. In fact, the proposition $(P \implies \eventually (\provable P))$ is \emph{false} within IC, because it is self-contradictory. (If true, it would be a statement that was true but not provable from the axioms!)
  
  We also cannot prove $(\provable P) \implies P$, even though we believe that all provable statements are true; but fortunately, $(\provable P) \implies (\eventually P)$ is a trivial corollary.
  
  (All of the following is conjecture, but I expect it to be true, at least once I have cleaned up any definitional mistakes:)
  
  With the provability predicate, we can prove:
  
  \[ \nameabstraction{P} \eventually (\provable (\eventually P)) \implies \eventually  P \]
  
  This theorem has an immediate corollary that is very significant:
  
  \[ \nameabstraction{P} \eventually (\provable (\eventually \bot)) \implies \eventually \bot \]
  

  %\printbibliography
\end{document}
