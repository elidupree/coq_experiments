use crate::introspective_calculus::{Formula, Atom, ExplicitRule, AbstractionKind};
use crate::introspective_calculus::inference::ProofLine;

grammar;

extern {
    type Error = String;
}

pub ExplicitRule: ExplicitRule = {
  <name:Name> ":=" <formula:Formula> => ExplicitRule{<>}
}

pub ProofLine: ProofLine = {
  <name:Name> "." <formula:Formula> => ProofLine{<>, ..ProofLine::default()},
  <name:Name> "." <formula:Formula> "[" <referents:CommaSeparated<Name>> "]" => ProofLine{name, formula, referents: referents.into_iter().collect(), ..ProofLine::default()},
  <name:Name> "." <formula:Formula> "[" <referents:(<Name> ",")*> "by" <deriver_name: Name?> "]" => ProofLine{name, formula, referents: referents.into_iter().collect(), deriver_name},
}

CommaSeparated<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

FormulaIndivisible: Formula = {
  Name => Formula::metavariable(<>),
  "(" <Formula> ")",

  "equals" => Formula::atom(Atom::Equals),
  "const" => Formula::atom(Atom::Const),
  "fuse" => Formula::atom(Atom::Fuse),

  "id" => Formula::id(),
  "All" => Formula::all(),
  //"And" => Formula::and_function(),
  "True" => Formula::prop_true(),
  "False" => Formula::prop_false(),
}

FormulaDivisibleRightOnly: Formula = {
}

FormulaDivisibleLeftOnly: Formula = {
  //<FormulaIndivisibleRight> "+1" => Formula::LevelSuccessor(<>)),
}

FormulaIndivisibleLeft: Formula = {
  FormulaDivisibleRightOnly,
  FormulaIndivisible,
}

FormulaIndivisibleRight: Formula = {
  FormulaDivisibleLeftOnly,
  FormulaIndivisible,
}

pub Formula: Formula = {
  <ApplyChain1> "&" <Formula> => Formula::and([<>]),
  <ApplyChain1> "->" <Formula> => Formula::implies([<>]),
  <ApplyChain1> "=" <Formula> => Formula::equals([<>]),
  ApplyChain2,
  ArrowChain2,
  FormulaDivisibleRightOnly,
  FormulaDivisibleLeftOnly,
  FormulaIndivisible,
}

ApplyChain1: Formula = {
  ApplyChain2,
  FormulaIndivisibleRight,
}
ApplyChain2: Formula = {
  ApplyChain1 FormulaIndivisibleLeft => Formula::apply([<>]),
}

ArrowChain1: Formula = {
  ArrowChain2,
  ApplyChain2,
  FormulaIndivisibleLeft,
}
ArrowChain2: Formula = {
  <n:Name> "=>" <r:ArrowChain1> => Formula::name_abstraction(AbstractionKind::Lambda, n, r),
  "âˆ€" <n:Name> "," <r:ArrowChain1> => Formula::name_abstraction(AbstractionKind::ForAll, n, r),
  //<antecedent:ApplyChain1> "->" <level:FormulaIndivisibleLeft> <consequent:ArrowChain1> => Formula::implies([<>])),
}

Name: String = r#"[a-zA-Z0-9_]+|"[a-zA-Z ]*""# => <>.to_string();
