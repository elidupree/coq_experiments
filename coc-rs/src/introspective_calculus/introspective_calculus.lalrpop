use std::sync::Arc;
use crate::introspective_calculus::{Formula, Atom, ExplicitRule, AbstractionKind};

grammar;

extern {
    type Error = String;
}

pub ExplicitRule: ExplicitRule = {
  <name:Name> ":=" <formula:Formula> => ExplicitRule{<>}
}

FormulaIndivisible: Formula = {
  Name => Formula::Metavariable(<>),
  "(" <Formula> ")",

  "0" => Formula::EmptySet,
  "empty_set" => Formula::Atom(Atom::EmptySet),
  "implies" => Formula::Atom(Atom::Implies),
  "union" => Formula::Atom(Atom::Union),
  "all" => Formula::Atom(Atom::All),
  "const" => Formula::Atom(Atom::Const),
  "fuse" => Formula::Atom(Atom::Fuse),
  //"IC" => Formula::Atom(Atom::Ic),
}

FormulaDivisibleRightOnly: Formula = {
}

FormulaDivisibleLeftOnly: Formula = {
  //<FormulaIndivisibleRight> "+1" => Formula::LevelSuccessor(Arc::new(<>)),
}

FormulaIndivisibleLeft: Formula = {
  FormulaDivisibleRightOnly,
  FormulaIndivisible,
}

FormulaIndivisibleRight: Formula = {
  FormulaDivisibleLeftOnly,
  FormulaIndivisible,
}

pub Formula: Formula = {
  <ApplyChain1> "+" <Formula> => Formula::Union(Arc::new([<>])),
  <ApplyChain1> "->" <Formula> => Formula::Implies(Arc::new([<>])),
  ApplyChain2,
  ArrowChain2,
  FormulaDivisibleRightOnly,
  FormulaDivisibleLeftOnly,
  FormulaIndivisible,
}

ApplyChain1: Formula = {
  ApplyChain2,
  FormulaIndivisibleRight,
}
ApplyChain2: Formula = {
  ApplyChain1 FormulaIndivisibleLeft => Formula::Apply(Arc::new([<>])),
}

ArrowChain1: Formula = {
  ArrowChain2,
  ApplyChain2,
  FormulaIndivisibleLeft,
}
ArrowChain2: Formula = {
  <n:Name> "=>" <r:ArrowChain1> => Formula::NameAbstraction(AbstractionKind::Lambda, n, Arc::new(r)),
  "âˆ€" <n:Name> "," <r:ArrowChain1> => Formula::NameAbstraction(AbstractionKind::ForAll, n, Arc::new(r)),
  //<antecedent:ApplyChain1> "->" <level:FormulaIndivisibleLeft> <consequent:ArrowChain1> => Formula::Implies(Arc::new(Implies{<>})),
}

Name: String = r#"[a-zA-Z_][a-zA-Z0-9_]*|"[a-zA-Z ]*""# => <>.to_string();
