use crate::introspective_calculus::{Formula, Atom, ExplicitRule, AbstractionKind};

grammar;

extern {
    type Error = String;
}

pub ExplicitRule: ExplicitRule = {
  <name:Name> ":=" <formula:Formula> => ExplicitRule{<>}
}

FormulaIndivisible: Formula = {
  Name => Formula::metavariable(<>),
  "(" <Formula> ")",

  "and" => Formula::atom(Atom::And),
  "equals" => Formula::atom(Atom::Equals),
  "const" => Formula::atom(Atom::Const),
  "fuse" => Formula::atom(Atom::Fuse),
}

FormulaDivisibleRightOnly: Formula = {
}

FormulaDivisibleLeftOnly: Formula = {
  //<FormulaIndivisibleRight> "+1" => Formula::LevelSuccessor(<>)),
}

FormulaIndivisibleLeft: Formula = {
  FormulaDivisibleRightOnly,
  FormulaIndivisible,
}

FormulaIndivisibleRight: Formula = {
  FormulaDivisibleLeftOnly,
  FormulaIndivisible,
}

pub Formula: Formula = {
  <ApplyChain1> "&" <Formula> => Formula::and([<>]),
  <ApplyChain1> "->" <Formula> => Formula::implies([<>]),
  <ApplyChain1> "=" <Formula> => Formula::equals([<>]),
  ApplyChain2,
  ArrowChain2,
  FormulaDivisibleRightOnly,
  FormulaDivisibleLeftOnly,
  FormulaIndivisible,
}

ApplyChain1: Formula = {
  ApplyChain2,
  FormulaIndivisibleRight,
}
ApplyChain2: Formula = {
  ApplyChain1 FormulaIndivisibleLeft => Formula::apply([<>]),
}

ArrowChain1: Formula = {
  ArrowChain2,
  ApplyChain2,
  FormulaIndivisibleLeft,
}
ArrowChain2: Formula = {
  <n:Name> "=>" <r:ArrowChain1> => Formula::name_abstraction(AbstractionKind::Lambda, n, r),
  "âˆ€" <n:Name> "," <r:ArrowChain1> => Formula::name_abstraction(AbstractionKind::ForAll, n, r),
  //<antecedent:ApplyChain1> "->" <level:FormulaIndivisibleLeft> <consequent:ArrowChain1> => Formula::implies([<>])),
}

Name: String = r#"[a-zA-Z_][a-zA-Z0-9_]*|"[a-zA-Z ]*""# => <>.to_string();
