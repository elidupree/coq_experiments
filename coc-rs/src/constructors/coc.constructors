/* Many of the rules work the same way for lambdas and foralls,
  so we use the same Term constructor (`Abstraction`) for both of them, and just specify which one using this type. */
data AbstractionKind;
Lambda () -> AbstractionKind, notated "λ";
ForAll () -> AbstractionKind, notated "∀";

data Sort;
Type () -> Sort, notated "𝕋";
Prop () -> Sort, notated "ℙ";

data Term;
SortTerm (s:Sort) -> Term, notated "{s}";
VariableUsage () -> Term, notated "𝕍";
Abstraction (kind: AbstractionKind, argument_type: Term, body: Term, bindings: BindingTree) -> Term, notated "{kind}({bindings}:{argument_type}), {body}";
Apply (m: Term, n: Term) -> Term, notated "({m} {n})";

data BindingTree;
BindNotThis () -> BindingTree, notated "∅";
BindVariable () -> BindingTree, notated "𝕍";
BindBranch (m: BindingTree, n: BindingTree) -> BindingTree, notated "({m} {n})";

data WhichBetaReduction;
BetaReductionHere (replaced_bindings: BindingTree) -> WhichBetaReduction, notated "{replaced_bindings}";
BetaReductionL (reduction: WhichBetaReduction) -> WhichBetaReduction, notated "𝐿{reduction}";
BetaReductionR (reduction: WhichBetaReduction) -> WhichBetaReduction, notated "𝑅{reduction}";

/* a Context specifies the types and identities of some or all of the free variables within a particular term,
  by sharing the tree structure of the term. */
data Context;
ContextHole ()-> Context, notated "∅";
ContextKnownVariable (binding_term: Term, binding_context: Context)-> Context, notated "{binding_term}/{binding_context}";
ContextBranch(m: Context,n: Context)-> Context, notated "({m} {n})";

predicate EmptyBindingsShapedLike Term BindingTree, notated "{0}'s empty bindings are {1}";
EmptyBindingsShapedLikeVariable()-> EmptyBindingsShapedLike VariableUsage BindNotThis;
EmptyBindingsShapedLikeSort(s: Sort)-> EmptyBindingsShapedLike (SortTerm s) BindNotThis;
EmptyBindingsShapedLikeAbstraction(
    kind: AbstractionKind, argument_type: Term, body: Term, bindings: BindingTree,
    a: BindingTree, b: BindingTree,
)-> EmptyBindingsShapedLike (Abstraction kind argument_type body bindings) (BindBranch a b);
EmptyBindingsShapedLikeApply(
    m: Term, n: Term,
    a: BindingTree, b: BindingTree,
)-> EmptyBindingsShapedLike (Apply m n) (BindBranch a b);

/* Note: implicitly prevents binding the same thing a second time, by requiring ContextHole
  Similar structure to SingleSubstitution, and notated the same way; is there a better name, maybe? */
predicate AddBindingsToContext BindingTree Context Context Context, notated "{3} = {2}[{0}:={1}]";
AddBindingsToContextNotHere(inserted_context: Context) -> AddBindingsToContext BindNotThis inserted_context ContextHole ContextHole;
AddBindingsToContextVariable(inserted_context: Context) -> AddBindingsToContext BindVariable inserted_context ContextHole inserted_context;
AddBindingsToContextBranch (lb: BindingTree,rb: BindingTree,lc: Context, rc: Context,lc2: Context, rc2: Context,inserted_context: Context,
    _: AddBindingsToContext lb inserted_context lc lc2,
    _: AddBindingsToContext rb inserted_context rc rc2,
  )
  -> AddBindingsToContext (BindBranch lb rb) inserted_context (ContextBranch lc rc) (ContextBranch lc2 rc2);

/* Note: implicitly prevents growing from something that already has a BindVariable in 2
  Similar structure to SingleSubstitution, and notated the same way; is there a better name, maybe? */
predicate GrowFromLeaves BindingTree BindingTree BindingTree BindingTree, notated "{3} = {2}[{0}:={1}]";
GrowFromLeaf(inserted_bindings: BindingTree)
  -> GrowFromLeaves BindVariable inserted_bindings BindNotThis inserted_bindings;
GrowNotHere (inserted_bindings: BindingTree, original_bindings: BindingTree)
  -> GrowFromLeaves BindNotThis inserted_bindings original_bindings original_bindings;
GrowFromBranch(m: BindingTree, n: BindingTree, mb: BindingTree, nb: BindingTree, inserted_bindings: BindingTree,
    m2: BindingTree, n2: BindingTree,
    _:GrowFromLeaves mb inserted_bindings m m2,
    _:GrowFromLeaves nb inserted_bindings n n2,
)-> GrowFromLeaves (BindBranch mb nb) inserted_bindings (BindBranch m n) (BindBranch m2 n2);


/* how the bindings of an outer lambda/forall are transformed by a particular beta reduction;
  uses the same notation as BetaReductionOneStep, which is the same thing but for Terms */
predicate PortBindings WhichBetaReduction BindingTree BindingTree, notated "{1} →𝛽({0}) {2}";
PortBindingsHere(
    replaced_bindings: BindingTree,
    bindings_in_argument_type: BindingTree, bindings_in_body: BindingTree,
    bindings_in_argument: BindingTree,
    new_bindings: BindingTree,
    _: GrowFromLeaves replaced_bindings bindings_in_argument bindings_in_body new_bindings,
) -> PortBindings
  (BetaReductionHere replaced_bindings)
  (BindBranch (BindBranch bindings_in_argument_type bindings_in_body) bindings_in_argument)
  new_bindings;

PortBindingsL (
    reduction: WhichBetaReduction,
    m: BindingTree, n: BindingTree, m2: BindingTree,
    _: PortBindings reduction m m2,
)->PortBindings
  (BetaReductionL reduction)
  (BindBranch m n)
  (BindBranch m2 n);
PortBindingsR (
    reduction: WhichBetaReduction,
    m: BindingTree, n: BindingTree, n2: BindingTree,
    _: PortBindings reduction n n2,
)->PortBindings
  (BetaReductionR reduction)
  (BindBranch m n)
  (BindBranch m n2);

predicate SingleSubstitution BindingTree Term Term Term, notated "{3} = {2}[{0}:={1}]";
SingleSubstitutionNotHere (
    term: Term, replacement: Term
) -> SingleSubstitution BindNotThis replacement term term;

SingleSubstitutionBoundVariable (
    term: Term, replacement: Term
) -> SingleSubstitution BindVariable replacement VariableUsage replacement;

SingleSubstitutionAbstraction (
    kind: AbstractionKind, argument_type: Term, body: Term, bindings: BindingTree,
    argument_type2: Term, body2: Term, bindings2: BindingTree,
    argument_replaced_bindings: BindingTree, body_replaced_bindings: BindingTree,
    replacement: Term, replacement_empty_bindings: BindingTree,
    _ : SingleSubstitution argument_replaced_bindings replacement argument_type argument_type2,
    _ : SingleSubstitution body_replaced_bindings replacement body body2,
    _ : GrowFromLeaves body_replaced_bindings replacement_empty_bindings bindings bindings2,
    _ : EmptyBindingsShapedLike replacement replacement_empty_bindings,
) -> SingleSubstitution
    (BindBranch argument_replaced_bindings body_replaced_bindings)
    replacement
    (Abstraction kind argument_type body bindings)
    (Abstraction kind argument_type2 body2 bindings2);

SingleSubstitutionApply (
    repl: Term, m: Term, n: Term, m2: Term, n2: Term, mb: BindingTree, nb: BindingTree,
    _ : SingleSubstitution mb repl m m2,
    _ : SingleSubstitution nb repl n n2,
) -> SingleSubstitution (BindBranch mb nb) repl (Apply m n) (Apply m2 n2);

predicate BetaReductionOneStep WhichBetaReduction Term Term, notated "{1} →𝛽({0}) {2}";
BetaReduction (
    argument_type: Term, body: Term, bindings: BindingTree,
    argument: Term,
    result: Term,
    _:SingleSubstitution bindings argument body result,
)-> BetaReductionOneStep (BetaReductionHere bindings) (Apply (Abstraction Lambda argument_type body bindings) argument) result;

BetaCompatibilityApplyLeft (
    m: Term, n: Term, m2: Term,
    reduction: WhichBetaReduction,
    _ : BetaReductionOneStep reduction m m2,
)-> BetaReductionOneStep (BetaReductionL reduction) (Apply m n) (Apply m2 n);

BetaCompatibilityApplyRight (
    m: Term, n: Term, n2: Term,
    reduction: WhichBetaReduction,
    _ : BetaReductionOneStep reduction n n2,
)-> BetaReductionOneStep (BetaReductionR reduction) (Apply m n) (Apply m n2);

BetaCompatibilityAbstractionArgType (
    kind: AbstractionKind, argument_type: Term, body: Term, bindings: BindingTree,
    argument_type2: Term,
    reduction: WhichBetaReduction,
    _ : BetaReductionOneStep reduction argument_type argument_type2,
)-> BetaReductionOneStep (BetaReductionL reduction)
     (Abstraction kind argument_type body bindings)
     (Abstraction kind argument_type2 body bindings);

BetaCompatibilityAbstractionBody (
    kind: AbstractionKind, argument_type: Term, body: Term, bindings: BindingTree, bindings2: BindingTree,
    body2: Term,
    reduction: WhichBetaReduction,
    _ : PortBindings reduction bindings bindings2,
    _ : BetaReductionOneStep reduction body body2,
)-> BetaReductionOneStep (BetaReductionR reduction)
     (Abstraction kind argument_type body bindings)
     (Abstraction kind argument_type body2 bindings2);


predicate BetaConversion Term Term, notated "{0} =𝛽 {1}";
BetaReductionIsConversion (reduction: WhichBetaReduction, a: Term, b: Term,
    _:BetaReductionOneStep reduction a b) -> BetaConversion a b;
BetaReflexive (term: Term) -> BetaConversion term term;
BetaSymmetric (x: Term, y: Term, _:BetaConversion x y)-> BetaConversion y x;
BetaTransitive (x: Term, y: Term, z: Term,_:BetaConversion x y,_:BetaConversion y z)-> BetaConversion x z;

predicate HasType Term Context Term Context, notated "{0} : {2} ({1}/{3})";
TypeOfProp() -> HasType (SortTerm Prop) ContextHole (SortTerm Type) ContextHole;
TypeOfVariableUsage(
    kind: AbstractionKind, argument_type: Term, body: Term, bindings: BindingTree,
    argument_context: Context, body_context: Context,
) -> HasType
  VariableUsage (ContextKnownVariable (Abstraction kind argument_type body bindings) (ContextBranch argument_context body_context))
  argument_type argument_context;

TypeOfForAll (
    argument_type: Term, return_type: Term, argument_context: Context, return_context: Context, return_context_before_bindings: Context, bindings: BindingTree,
    s1 : Sort, s2 : Sort,
    _ : HasType argument_type argument_context (SortTerm s1) ContextHole,
    _ : HasType return_type return_context (SortTerm s2) ContextHole,
    _ : AddBindingsToContext bindings (ContextKnownVariable (Abstraction ForAll argument_type return_type bindings) (ContextBranch argument_context return_context_before_bindings)) return_context_before_bindings return_context
) -> HasType
    (Abstraction ForAll argument_type return_type bindings)
    (ContextBranch argument_context return_context_before_bindings)
    (SortTerm s2) ContextHole;

TypeOfLambda (
    argument_type: Term, argument_context: Context,
    body: Term, body_context: Context, body_context_before_bindings: Context,
    return_type: Term, return_context: Context, return_context_before_bindings: Context,
    lambda_bindings: BindingTree, forall_bindings: BindingTree,
    s : Term,
    _ : HasType (Abstraction ForAll argument_type return_type forall_bindings) (ContextBranch argument_context return_context_before_bindings) s ContextHole,
    _ : HasType body body_context return_type return_context,
    _ : AddBindingsToContext lambda_bindings (ContextKnownVariable (Abstraction Lambda argument_type body lambda_bindings) (ContextBranch argument_context body_context_before_bindings)) body_context_before_bindings body_context
) -> HasType
    (Abstraction Lambda argument_type body lambda_bindings)
    (ContextBranch argument_context body_context_before_bindings)
    (Abstraction ForAll argument_type return_type forall_bindings)
    (ContextBranch argument_context return_context_before_bindings);

TypeBetaConversion (
    value: Term, value_context: Context,
    ty: Term, type_context: Context,
    ty2: Term,
    s: Sort,
    _ : HasType value value_context ty type_context,
    _ : HasType ty2 type_context (SortTerm s) ContextHole,
    _ : BetaConversion ty ty2,
) -> HasType value value_context ty2 type_context;