/* Many of the rules work the same way for lambdas and foralls,
  so we use the same Formula constructor (`Abstraction`) for both of them, and just specify which one using this type. */
data AbstractionKind;
Lambda () -> AbstractionKind, notated "λ";
ForAll () -> AbstractionKind, notated "∀";

data Sort;
Kind () -> Sort, notated "𝕂";
Prop () -> Sort, notated "ℙ";

data Formula;
SortFormula (s:Sort) -> Formula, notated "{s}";
Hole () -> Formula, notated "𝕍";
KnownFreeVariable (type: Formula, namespace_competitors: Formula) -> Formula,
  notated "@{type}({namespace_competitors})";
Abstraction (kind: AbstractionKind, argument_type: Formula, body: Formula, bindings: BindingTree) -> Formula, notated "{kind}({bindings}:{argument_type}), {body}";
Apply (m: Formula, n: Formula) -> Formula, notated "({m} {n})";

data BindingTree;
BindNotThis () -> BindingTree, notated "∅";
BindVariable () -> BindingTree, notated "𝕍";
BindBranch (m: BindingTree, n: BindingTree) -> BindingTree, notated "({m} {n})";

data WhichBetaReduction;
BetaReductionHere (replaced_bindings: BindingTree) -> WhichBetaReduction, notated "{replaced_bindings}";
BetaReductionL (reduction: WhichBetaReduction) -> WhichBetaReduction, notated "𝐿{reduction}";
BetaReductionR (reduction: WhichBetaReduction) -> WhichBetaReduction, notated "𝑅{reduction}";

predicate EmptyBindingsShapedLike Formula BindingTree, notated "{0}'s empty bindings are {1}";
EmptyBindingsShapedLikeVariable()-> EmptyBindingsShapedLike VariableUsage BindNotThis;
EmptyBindingsShapedLikeSort(s: Sort)-> EmptyBindingsShapedLike (SortFormula s) BindNotThis;
EmptyBindingsShapedLikeAbstraction(
    kind: AbstractionKind, argument_type: Formula, body: Formula, bindings: BindingTree,
    a: BindingTree, b: BindingTree,
    _: EmptyBindingsShapedLike argument_type a,
    _: EmptyBindingsShapedLike body b,
)-> EmptyBindingsShapedLike (Abstraction kind argument_type body bindings) (BindBranch a b);
EmptyBindingsShapedLikeApply(
    m: Formula, n: Formula,
    a: BindingTree, b: BindingTree,
    _: EmptyBindingsShapedLike m a,
    _: EmptyBindingsShapedLike n b,
)-> EmptyBindingsShapedLike (Apply m n) (BindBranch a b);

/* Note: implicitly prevents growing from something that already has a BindVariable in 2
  Similar structure to SingleSubstitution, and notated the same way; is there a better name, maybe? */
predicate GrowFromLeaves BindingTree BindingTree BindingTree BindingTree, notated "{3} = {2}[{0}:={1}]";
GrowFromLeaf(inserted_bindings: BindingTree)
  -> GrowFromLeaves BindVariable inserted_bindings BindNotThis inserted_bindings;
GrowNotHere (inserted_bindings: BindingTree, original_bindings: BindingTree)
  -> GrowFromLeaves BindNotThis inserted_bindings original_bindings original_bindings;
GrowFromBranch(m: BindingTree, n: BindingTree, mb: BindingTree, nb: BindingTree, inserted_bindings: BindingTree,
    m2: BindingTree, n2: BindingTree,
    _:GrowFromLeaves mb inserted_bindings m m2,
    _:GrowFromLeaves nb inserted_bindings n n2,
)-> GrowFromLeaves (BindBranch mb nb) inserted_bindings (BindBranch m n) (BindBranch m2 n2);

predicate SingleSubstitution BindingTree Formula Formula Formula, notated "{3} = {2}[{0}:={1}]";
SingleSubstitutionNotHere (
    formula: Formula, replacement: Formula
) -> SingleSubstitution BindNotThis replacement formula formula;

/* Note: implicitly prevents binding the same thing a second time, by requiring Hole */
SingleSubstitutionBoundVariable (
    formula: Formula, replacement: Formula
) -> SingleSubstitution BindVariable replacement Hole replacement;

SingleSubstitutionAbstraction (
    kind: AbstractionKind, argument_type: Formula, body: Formula, bindings: BindingTree,
    argument_type2: Formula, body2: Formula, bindings2: BindingTree,
    argument_replaced_bindings: BindingTree, body_replaced_bindings: BindingTree,
    replacement: Formula, replacement_empty_bindings: BindingTree,
    _ : SingleSubstitution argument_replaced_bindings replacement argument_type argument_type2,
    _ : SingleSubstitution body_replaced_bindings replacement body body2,
    _ : GrowFromLeaves body_replaced_bindings replacement_empty_bindings bindings bindings2,
    _ : EmptyBindingsShapedLike replacement replacement_empty_bindings,
) -> SingleSubstitution
    (BindBranch argument_replaced_bindings body_replaced_bindings)
    replacement
    (Abstraction kind argument_type body bindings)
    (Abstraction kind argument_type2 body2 bindings2);

SingleSubstitutionApply (
    repl: Formula, m: Formula, n: Formula, m2: Formula, n2: Formula, mb: BindingTree, nb: BindingTree,
    _ : SingleSubstitution mb repl m m2,
    _ : SingleSubstitution nb repl n n2,
) -> SingleSubstitution (BindBranch mb nb) repl (Apply m n) (Apply m2 n2);




/* how the bindings of an outer lambda/forall are transformed by a particular beta reduction;
  uses the same notation as BetaReductionOneStep, which is the same thing but for Formulas */
predicate PortBindings WhichBetaReduction BindingTree BindingTree, notated "{1} →𝛽({0}) {2}";
predicate BetaReductionOneStep WhichBetaReduction Formula Formula, notated "{1} →𝛽({0}) {2}";
BetaReduction (
    argument_type: Formula, body: Formula, bindings: BindingTree,
    argument: Formula,
    result: Formula,
    _:SingleSubstitution bindings argument body result,
)-> BetaReductionOneStep
  (BetaReductionHere bindings)
  (Apply (Abstraction Lambda argument_type body bindings) argument)
  result;
PortBindingsHere(
    replaced_bindings: BindingTree,
    bindings_in_argument_type: BindingTree, bindings_in_body: BindingTree,
    bindings_in_argument: BindingTree,
    new_bindings: BindingTree,
    _: GrowFromLeaves replaced_bindings bindings_in_argument bindings_in_body new_bindings,
) -> PortBindings
  (BetaReductionHere replaced_bindings)
  (BindBranch (BindBranch bindings_in_argument_type bindings_in_body) bindings_in_argument)
  new_bindings;

BetaCompatibilityApplyLeft (
    m: Formula, n: Formula, m2: Formula,
    reduction: WhichBetaReduction,
    _ : BetaReductionOneStep reduction m m2,
)-> BetaReductionOneStep (BetaReductionL reduction) (Apply m n) (Apply m2 n);

PortBindingsL (
    reduction: WhichBetaReduction,
    m: BindingTree, n: BindingTree, m2: BindingTree,
    _: PortBindings reduction m m2,
)->PortBindings
  (BetaReductionL reduction)
  (BindBranch m n)
  (BindBranch m2 n);

BetaCompatibilityApplyRight (
    m: Formula, n: Formula, n2: Formula,
    reduction: WhichBetaReduction,
    _ : BetaReductionOneStep reduction n n2,
)-> BetaReductionOneStep (BetaReductionR reduction) (Apply m n) (Apply m n2);
PortBindingsR (
    reduction: WhichBetaReduction,
    m: BindingTree, n: BindingTree, n2: BindingTree,
    _: PortBindings reduction n n2,
)->PortBindings
  (BetaReductionR reduction)
  (BindBranch m n)
  (BindBranch m n2);

BetaCompatibilityAbstractionArgType (
    kind: AbstractionKind, argument_type: Formula, body: Formula, bindings: BindingTree,
    argument_type2: Formula,
    reduction: WhichBetaReduction,
    _ : BetaReductionOneStep reduction argument_type argument_type2,
)-> BetaReductionOneStep (BetaReductionL reduction)
     (Abstraction kind argument_type body bindings)
     (Abstraction kind argument_type2 body bindings);

BetaCompatibilityAbstractionBody (
    kind: AbstractionKind, argument_type: Formula, body: Formula, bindings: BindingTree, bindings2: BindingTree,
    body2: Formula,
    reduction: WhichBetaReduction,
    _ : PortBindings reduction bindings bindings2,
    _ : BetaReductionOneStep reduction body body2,
)-> BetaReductionOneStep (BetaReductionR reduction)
     (Abstraction kind argument_type body bindings)
     (Abstraction kind argument_type body2 bindings2);


predicate BetaConversion Formula Formula, notated "{0} =𝛽 {1}";
BetaReductionIsConversion (reduction: WhichBetaReduction, a: Formula, b: Formula,
    _:BetaReductionOneStep reduction a b) -> BetaConversion a b;
BetaReflexive (formula: Formula) -> BetaConversion formula formula;
BetaSymmetric (x: Formula, y: Formula, _:BetaConversion x y)-> BetaConversion y x;
BetaTransitive (x: Formula, y: Formula, z: Formula,_:BetaConversion x y,_:BetaConversion y z)-> BetaConversion x z;

predicate HasType Formula Formula, notated "{0} : {2} ({1}/{3})";
TypeOfProp() -> HasType (SortFormula Prop) (SortFormula Kind);
TypeOfVariableUsage(
    type: Formula, namespace_competitors: Formula,
    s : Formula,
    _ : HasType type (SortFormula s),
) -> HasType (KnownFreeVariable type namespace_competitors) type;

TypeOfForAll (
    argument_type: Formula, return_type: Formula, return_type_after_bindings: Formula, bindings: BindingTree,
    s1 : Sort, s2 : Sort,
    _ : HasType argument_type (SortFormula s1),
    _ : HasType return_type_after_bindings (SortFormula s2),
    _ : SingleSubstitution bindings
      (KnownFreeVariable argument_type return_type)
      return_type return_type_after_bindings,
) -> HasType (Abstraction ForAll argument_type return_type bindings) (SortFormula s2);

/* Note: I don't know if the variable-identities below actually need to include return_type,
  or if just body is enough. Playing it safe though. */
TypeOfLambda (
    argument_type: Formula,
    body: Formula, body_after_bindings: Formula,
    return_type: Formula, return_type_after_bindings: Formula,
    lambda_bindings: BindingTree, forall_bindings: BindingTree,
    s : Formula,
    _ : HasType (Abstraction ForAll argument_type return_type_after_bindings forall_bindings) s,
    _ : HasType body_after_bindings return_type_after_bindings,
    _ : SingleSubstitution lambda_bindings
      (KnownFreeVariable argument_type (Apply body return_type))
      body body_after_bindings,
    _ : SingleSubstitution forall_bindings
      (KnownFreeVariable argument_type (Apply body return_type))
      return_type return_type_after_bindings,
) -> HasType
    (Abstraction Lambda argument_type body lambda_bindings)
    (Abstraction ForAll argument_type return_type forall_bindings);

TypeOfApply (
    function: Formula, argument: Formula,
    argument_type: Formula, return_type: Formula, forall_bindings: BindingTree,
    result_type: Formula,
    _ : HasType function (Abstraction ForAll argument_type return_type forall_bindings),
    _ : HasType argument argument_type,
    _ : SingleSubstitution forall_bindings argument return_type result_type,
) -> HasType (Apply function argument) result_type;

TypeBetaConversion (
    member: Formula,
    ty: Formula,
    ty2: Formula,
    s: Sort,
    _ : HasType member ty,
    _ : HasType ty2 (SortFormula s),
    _ : BetaConversion ty ty2,
) -> HasType member ty2;